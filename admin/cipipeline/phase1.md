# PIPELINE STATUS

The pipeline’s automatic features are currently completely functional in terms of being able to run both end-to-end and unit tests, check for linting errors, commit Prettier’s auto-formatting changes from Github Actions, and displaying code quality score metrics.

Unit tests are covered by Jest, where it tests each database API method by simulating CRUD features and generating random recipe entries. Cypress tests can successfully login with a fake user, and interact with the web application in basic ways (click on links to open up the right views, ensure certain elements are visible on the screen in a certain state, etc.) Linting is covered locally by ESLint and Stylelint, and it’s covered in our continuous integration pipeline by Github’s Super Linter (a Github Action that combines many popular linters and evaluates the entire codebase with them, which is easy to integrate into our actions workflow.) Formatting is covered by Prettier, both locally (either from the CLI or automatically formats via VSCode plugin) and as a Github action. Code quality is evaluated by SonarCloud, which uses SonarQube behind the scenes to offer cloud-powered evaluations of code quality that is easily integrated with Github Actions. Finally, JSDocs generates code documentation and pushes the latest generated site to a specific branch that our Github Pages site will use. 

Other than the automatic features, manual steps include locally running Jest and Cypress tests along with running ESLint, Stylelint and Prettier before pushing or making a pull request. VSCode plugins can also make it very easy and convenient for developers to adhere to formatting and linting rules as they write code. We manually request reviews from other team members in our pull requests. Finally, we also make sure that each pull request has a corresponding issue filed in our Github repository’s Issues tab, and we also place the issue in the correct category in our Project Board (it’s based on progress: it can be “To do”, “In progress”, “Review in progress”, or “Done”.)

Although our team had some difficulties finalizing the pipeline initially, we were able to get these automatic actions functional in time for a discussion demonstration. Because some parts of our team were isolated from the development of the pipeline, some code quality and linting issues did pop up when the pipeline was finally merged into the main branch. However, now that all the linters, formatters, and code quality checks are in place for every pull request, our team’s code quality is held to a higher standard. Future pull requests should result in cleaner, better code.

In the future, we plan for our pipeline to not only deploy to a hosting service (our team has chosen to go with Glitch.com), but also explore more advanced topics such as evaluating code coverage (this should be covered by SonarCloud) and optimization steps such as minification or packaging. Hosting should be fairly straightforward to integrate into our pipeline; this step would come after the new features that were successfully merged into main are subjected to yet another round of automatic linting and quality checks. Code coverage is still a topic that our team needs to research, and this would require more comprehensive tests that touch on a lot of conditions and branches in our features. After these critical steps, optimization strategies like minification or packaging will be considered. ‘esbuild’ is currently being considered since the bundler’s fast build times (and included minification feature) would likely result in a comparably more positive developer experience than slower ones.
